{
  "content": "<h1 id=\"basic-concepts\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#basic-concepts\">#</a>Basic Concepts</h1>\n<p>Hero is not the only programable browser library -- Puppeteer, Playwright, Selenium, and others all have their advantages. But when it comes to scraping, Hero was built to shine.</p>\n<h2 id=\"each-hero-instance-is-a-unique-user\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#each-hero-instance-is-a-unique-user\">#</a>Each Hero Instance Is a Unique User</h2>\n<ul>\n<li>user-agent</li>\n<li>ip address</li>\n<li>cookies &#x26; storage</li>\n<li>screen details</li>\n<li>audio fingerprint (todo)</li>\n<li>fonts (todo)</li>\n<li>webgl / canvas  (todo)</li>\n<li>100s more</li>\n</ul>\n<p>Note: IP addresses are set through upstreamProxyUrl on each Hero.</p>\n<h2 id=\"the-dom-has-been-awaited\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#the-dom-has-been-awaited\">#</a>The DOM Has Been Awaited</h2>\n<p>The easiest way to explain Dynamic DOM is with some comparison examples. Let's say you want to load a URL and loop through a list of items.</p>\n<h3 id=\"doing-it-with-hero\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#doing-it-with-hero\">#</a>Doing It with Hero</h3>\n<p>Here's how you would do it with Hero:</p>\n<pre class=\"ulixeeTheme\"><code class=\"language-js\">import Hero from '@ulixee/hero-playground';\n\nconst { document } = hero;\n\nconst elems = document.querySelectorAll('ul');\nfor (const elem of await elems) {\n  console.log('SELECT FROM items WHERE id=?', [await elem.id]);\n  // ^^ WORKS\n}\n</code></pre>\n<p>Hero's Awaited DOM allows you to keep all calls within your script context. It also follows the W3C spec to a T. In fact, go ahead and copy lines 3 through 7 and run paste them into your browser's DevTools. They run perfectly.</p>\n<h3 id=\"doing-it-with-puppeteer\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#doing-it-with-puppeteer\">#</a>Doing It with Puppeteer</h3>\n<p>Here's how you would do it with Puppeteer:</p>\n<pre class=\"ulixeeTheme\"><code class=\"language-js\">const Puppeteer = require('puppeteer');\n\nconst selector = 'ul li';\npage.evaluate(\n  (selector, db) => {\n    const elems = document.querySelectorAll(selector);\n    for (const elem of elems) {\n      console.log('SELECT FROM items WHERE id=?', [elem.id]);\n      // ^^ BREAKS\n    }\n  },\n  selector,\n  db,\n);\n</code></pre>\n<p>As you'll notice, the above example throws an error. Although you can pass arguments into a remote method, they must be serializable, which means you can only pass through simple types.</p>\n<p>When used in a simple example as show above, Puppeteer's approach seems okay. However, the reality is, most scraper scripts are complex, and your code becomes littered with multiple contexts, adding context to an already complex environment.</p>\n<h2 id=\"headless-browsers-need-not-always-render\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#headless-browsers-need-not-always-render\">#</a>Headless Browsers Need Not Always Render</h2>\n<p>When you're trying to eke out performance, a common technique is to disable rendering various parts of a webpage. Hero allows you to <a href=\"/docs/hero/overview/configuration#blocked-resources\">turn off</a> everything from the style and images of a page, to the javascript environment. You can even simulate making http requests from inside a loaded web page, without ever loading the page.</p>\n<pre class=\"ulixeeTheme\"><code class=\"language-js\">import Hero from '@ulixee/hero-playground';\n\nconst hero = new Hero({\n  blockedResourceTypes: ['All'],\n});\nawait hero.goto('https://ulixee.org');\n// referer will be https://ulixee.org\nconst doc = await hero.fetch('https://ulixee.org/docs/hero/overview/configuration');\n</code></pre>\n<p>Next to <code>blockedResourceTypes</code> you can also use <code>blockedResourceUrls</code>,\nsee <a href=\"/docs/hero/overview/configuration#blocked-urls\">here</a> for more information.</p>\n<h2 id=\"mice-and-keyboards-are-human-too\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#mice-and-keyboards-are-human-too\">#</a>Mice and Keyboards Are Human Too</h2>\n<p>Hero drives mice and keyboards with <a href=\"https://github.com/ulixee/hero/tree/main/plugins/default-human-emulator\">Human Emulators</a>. Human emulators translate your clicks and moves into randomized human-like patterns that can pass bot-blocker checks.</p>",
  "title": "Basic Concepts",
  "subtitles": [
    {
      "depth": 2,
      "value": "Each Hero Instance Is a Unique User",
      "anchor": "#each-hero-instance-is-a-unique-user"
    },
    {
      "depth": 2,
      "value": "The DOM Has Been Awaited",
      "anchor": "#the-dom-has-been-awaited"
    },
    {
      "depth": 3,
      "value": "Doing It with Hero",
      "anchor": "#doing-it-with-hero"
    },
    {
      "depth": 3,
      "value": "Doing It with Puppeteer",
      "anchor": "#doing-it-with-puppeteer"
    },
    {
      "depth": 2,
      "value": "Headless Browsers Need Not Always Render",
      "anchor": "#headless-browsers-need-not-always-render"
    },
    {
      "depth": 2,
      "value": "Mice and Keyboards Are Human Too",
      "anchor": "#mice-and-keyboards-are-human-too"
    }
  ]
}