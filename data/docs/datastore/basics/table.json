{
  "content": "<h1 id=\"table\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#table\">#</a>Table</h1>\n<p>A Table is a storage mechanism for structured data records (just like a SQL Database table). The following is a simple example:</p>\n<pre class=\"ulixeeTheme\"><code class=\"language-js\">import { Table } from '@ulixee/datastore';\n\nconst table = new Table({\n  schema: {\n    title: string(),\n    success: boolean(),\n  },\n  async onCreated() {\n    await this.insertInternal(\n      { title: 'Hello', success: true },\n      { title: 'World', success: false },\n    );\n  },\n});\n\n// will log { title: 'Hello', success: true }\ntable.queryInternal(`select * from self where success=$1`, [true]).then(console.log);\n</code></pre>\n<h2 id=\"constructor\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#constructor\">#</a>Constructor</h2>\n<h3 id=\"constructor\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#constructor\">#</a>new Table <em>(components)</em></h3>\n<p>Creates a new Table instance.</p>\n<h4 id=\"arguments\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#arguments\">#</a><strong>Arguments</strong>:</h4>\n<p>Components contains the following properties.</p>\n<ul>\n<li>schema <code>ISchema</code>. A <a href=\"/docs/datastore/advanced/schema\">schema</a> defining the column definitions for the table.</li>\n<li>isPublic <code>boolean</code>. Optional parameter to make a table private. This means it can only be accessed by other <a href=\"/docs/datastore/basics/extractor\">Extractors</a> and <a href=\"/docs/datastore/basics/crawler\">Crawlers</a> in the same <a href=\"/docs/datastore/basics/datastore\">Datastore</a>.</li>\n<li>basePrice <code>number</code>. Optional price per access. It's called \"base price\" because a query might join multiple data entities.</li>\n<li>onCreated <code>function</code>. A function run when the Table is installed onto a StorageEngine. This is where you can seed any records in the engine. More details are <a href=\"#on-created\">here</a>.</li>\n<li>onVersionMigrated <code>function</code>. A function run when a Table is installed onto a StorageEngine and there is a previous version of the Table. This is a function to perform \"migrations\" and copy any data from the previous version that you want. More details are <a href=\"#on-version-migrated\">here</a></li>\n<li>name <code>string</code>. Optional name for this Table, primarily used only if defining a Table outside a Datastore.</li>\n<li>description <code>string</code>. Optional description to use for documentation of the Table.</li>\n</ul>\n<h3 id=\"on-created\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#on-created\">#</a>onCreated <em>()</em></h3>\n<p>An optional callback that can be used to bootstrap a Table when it's installed onto a Storage Engine. This method allows you to seed the table. It will be called only once.</p>\n<p>The callback is called from the context of the Table object, so you can directly use the table's methods.</p>\n<pre class=\"ulixeeTheme\"><code class=\"language-js\">import Datastore from '@ulixee/datastore';\n\nconst whitelist = new Set([`id1xv7empyzlwuvlshs2vlf9eruf72jeesr8yxrrd3esusj75qsr6jqj6dv3p`]);\n\nexport default new Datastore({\n  tables: {\n    events: new Table({\n      schema: {\n        name: string(),\n        date: date(),\n      },\n    }),\n    async onCreated() {\n      await this.insertInternal({\n        name: 'Thanksgiving',\n        birthdate: new Date('2023-11-01'),\n      });\n    },\n  },\n});\n</code></pre>\n<h3 id=\"on-version-migrated\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#on-version-migrated\">#</a>onVersionMigrated <em>(previousVersion)</em></h3>\n<p>An optional callback that will be called when this Table is installed onto a Storage Engine where a previous Table version exists. All tables start off empty for each version, so you must copy any data you want to keep from the previous Datastore Table.</p>\n<p>This callback will only be called once, and only if a previous version is on the cloud where it will be installed.</p>\n<h4 id=\"arguments-1\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#arguments-1\">#</a><strong>Arguments</strong>:</h4>\n<ul>\n<li>previousVersion <code>Table</code>. The previous linked version of a table with the samename.</li>\n</ul>\n<p>Below is simple example for migrating data to the new table by filling in the new columns.</p>\n<p>NOTE: since each Datastore version creates a new copy of the table, you can test migrations locally by pointing at your previous version and testing out migrating to a new one.</p>\n<pre class=\"ulixeeTheme\"><code class=\"language-js\">import Datastore from '@ulixee/datastore';\n\nexport default new Datastore({\n  tables: {\n    events: new Table({\n      schema: {\n        name: string(),\n        reason: string({ enum: ['fun', 'work'] }),\n        date: date(),\n      },\n      async onVersionMigrated(previousTable) {\n        const previousEvents = await previousTable.fetchInternal();\n        for (const previousEvent of previousEvents) {\n          await this.insertInternal(\n            ...previousEvents.map(x => ({\n              ...x,\n              reason: 'fun',\n            })),\n          );\n        }\n      },\n    }),\n  },\n});\n</code></pre>\n<h2 id=\"methods\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#methods\">#</a>Methods</h2>\n<h3 id=\"query\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#query\">#</a>queryInternal <em>(sql, boundValues)</em></h3>\n<p>Internal method to query the table. This method can be used without attaching a Table to any Datastore if you wish to test it out. Your table name can optionally be <code>self</code> in this method.</p>\n<h4 id=\"arguments-2\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#arguments-2\">#</a><strong>Arguments</strong>:</h4>\n<ul>\n<li>sql <code>string</code>. A <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code> or <code>INSERT</code> Sql query. SQL parameters must use \"named\" access starting at index 1 (eg, <code>UPDATE records SET item=$1 where key=$2</code>).</li>\n<li>boundValues <code>any[]</code>. An array of javascript values to query by. Position 0 will fill <code>$1</code> in the query. All arguments are sanitized for security and converted to be compatible with the underlying SQL engine.</li>\n</ul>\n<h4 id=\"return-promise-a-promise-containing-the-results-of-the-sql-query\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#return-promise-a-promise-containing-the-results-of-the-sql-query\">#</a>Return Promise<any>. A promise containing the results of the SQL query.</h4>\n<h3 id=\"fetch\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#fetch\">#</a>fetchInternal <em>(filter)</em></h3>\n<p>Internal method to fetch records from the table. This method accepts where clause \"inputs\" only.</p>\n<h4 id=\"arguments-3\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#arguments-3\">#</a><strong>Arguments</strong>:</h4>\n<ul>\n<li>filter <code>object</code>. Record containing any key/values you wish to filter with.</li>\n</ul>\n<h4 id=\"return-promise-a-promise-containing-the-records-returned-from-the-filter\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#return-promise-a-promise-containing-the-records-returned-from-the-filter\">#</a>Return Promise&#x3C;[]>. A promise containing the records returned from the filter.</h4>",
  "title": "Table",
  "subtitles": [
    {
      "depth": 2,
      "value": "Constructor",
      "anchor": "#constructor"
    },
    {
      "depth": 3,
      "value": "new Table <em>(components)</em>",
      "anchor": "#constructor"
    },
    {
      "depth": 3,
      "value": "onCreated <em>()</em>",
      "anchor": "#on-created"
    },
    {
      "depth": 3,
      "value": "onVersionMigrated <em>(previousVersion)</em>",
      "anchor": "#on-version-migrated"
    },
    {
      "depth": 2,
      "value": "Methods",
      "anchor": "#methods"
    },
    {
      "depth": 3,
      "value": "queryInternal <em>(sql, boundValues)</em>",
      "anchor": "#query"
    },
    {
      "depth": 3,
      "value": "fetchInternal <em>(filter)</em>",
      "anchor": "#fetch"
    }
  ]
}